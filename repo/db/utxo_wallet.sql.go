// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: utxo_wallet.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const findUnspentUTXOsGTETarget = `-- name: FindUnspentUTXOsGTETarget :many
WITH RECURSIVE candidate AS (
    SELECT u.tx_id, u.wallet_id, u.amount, u.created_at, u.spent_at,
        u.amount::NUMERIC(20,12) AS acc
    FROM (
        SELECT tx_id, wallet_id, amount, created_at, spent_at
        FROM utxo_wallet
        WHERE utxo_wallet.wallet_id = $1
        AND utxo_wallet.spent_at IS NULL
        ORDER BY utxo_wallet.tx_id
        LIMIT 1
        FOR UPDATE SKIP LOCKED
    ) AS u

    UNION ALL

    SELECT u.tx_id, u.wallet_id, u.amount, u.created_at, u.spent_at,
        (c.acc + u.amount)::NUMERIC(20,12) AS acc
    FROM candidate AS c
    JOIN LATERAL (
        SELECT tx_id, wallet_id, amount, created_at, spent_at
        FROM utxo_wallet
        WHERE utxo_wallet.wallet_id = c.wallet_id
        AND utxo_wallet.spent_at IS NULL
        AND utxo_wallet.tx_id > c.tx_id
        ORDER BY utxo_wallet.tx_id
        LIMIT 1
        FOR UPDATE SKIP LOCKED
    ) AS u ON true
    WHERE c.acc < $2::NUMERIC(20,12)
)
SELECT tx_id, wallet_id, amount, created_at, spent_at
FROM candidate
`

type FindUnspentUTXOsGTETargetParams struct {
	WalletID int32          `db:"wallet_id" json:"wallet_id"`
	Target   pgtype.Numeric `db:"target" json:"target"`
}

type FindUnspentUTXOsGTETargetRow struct {
	TxID      uuid.UUID        `db:"tx_id" json:"tx_id"`
	WalletID  int32            `db:"wallet_id" json:"wallet_id"`
	Amount    pgtype.Numeric   `db:"amount" json:"amount"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	SpentAt   pgtype.Timestamp `db:"spent_at" json:"spent_at"`
}

func (q *Queries) FindUnspentUTXOsGTETarget(ctx context.Context, arg FindUnspentUTXOsGTETargetParams) ([]FindUnspentUTXOsGTETargetRow, error) {
	rows, err := q.db.Query(ctx, findUnspentUTXOsGTETarget, arg.WalletID, arg.Target)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUnspentUTXOsGTETargetRow
	for rows.Next() {
		var i FindUnspentUTXOsGTETargetRow
		if err := rows.Scan(
			&i.TxID,
			&i.WalletID,
			&i.Amount,
			&i.CreatedAt,
			&i.SpentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUTXOWalletBalanceForUpdate = `-- name: GetUTXOWalletBalanceForUpdate :one
WITH locked AS (
    SELECT tx_id, wallet_id, amount, created_at, spent_at
    FROM utxo_wallet
    WHERE wallet_id = $1
    AND spent_at IS NULL
    FOR UPDATE
)
SELECT
    wallet_id,
    COALESCE(SUM(amount), 0)::NUMERIC(20,12) AS total_amount,
    MAX(created_at) AS last_created_at,
    MAX(created_at) AS last_updated_at
FROM locked
GROUP BY wallet_id
`

type GetUTXOWalletBalanceForUpdateRow struct {
	WalletID      int32          `db:"wallet_id" json:"wallet_id"`
	TotalAmount   pgtype.Numeric `db:"total_amount" json:"total_amount"`
	LastCreatedAt interface{}    `db:"last_created_at" json:"last_created_at"`
	LastUpdatedAt interface{}    `db:"last_updated_at" json:"last_updated_at"`
}

func (q *Queries) GetUTXOWalletBalanceForUpdate(ctx context.Context, walletID int32) (GetUTXOWalletBalanceForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getUTXOWalletBalanceForUpdate, walletID)
	var i GetUTXOWalletBalanceForUpdateRow
	err := row.Scan(
		&i.WalletID,
		&i.TotalAmount,
		&i.LastCreatedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const insertUTXO = `-- name: InsertUTXO :exec
INSERT INTO utxo_wallet (tx_id, wallet_id, amount, created_at)
VALUES ($1, $2, $3, now())
`

type InsertUTXOParams struct {
	TxID     uuid.UUID      `db:"tx_id" json:"tx_id"`
	WalletID int32          `db:"wallet_id" json:"wallet_id"`
	Amount   pgtype.Numeric `db:"amount" json:"amount"`
}

func (q *Queries) InsertUTXO(ctx context.Context, arg InsertUTXOParams) error {
	_, err := q.db.Exec(ctx, insertUTXO, arg.TxID, arg.WalletID, arg.Amount)
	return err
}

const markUTXOsAsSpent = `-- name: MarkUTXOsAsSpent :exec
UPDATE utxo_wallet
SET spent_at = now()
WHERE tx_id = ANY($1::uuid[])
`

func (q *Queries) MarkUTXOsAsSpent(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, markUTXOsAsSpent, dollar_1)
	return err
}
